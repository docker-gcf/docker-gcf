#!/usr/bin/env bash
#   Use this script to wait for a test command to succeed with a timeout

cmdname="$(basename "${0}")"

CMD=()
CLI=()

echoerr()
{
    if [[ "${QUIET}" -ne 1 ]]
    then
        echo "${@}" 1>&2
    fi
}

usage()
{
    cat << USAGE >&2
Usage:
    ${cmdname} [-s] [-q] [-t timeout] test_command args [-- command args]
    -s | --strict               Only execute subcommand if the test succeeds
    -q | --quiet                Don't output any status messages
    -t TIMEOUT | --timeout=TIMEOUT
                                Timeout in seconds, zero for no timeout
    -- TEST_COMMAND ARGS                Execute command with args as test
    -- COMMAND ARGS             Execute command with args after the test finishes
USAGE
    exit 1
}

wait_for()
{
    if [[ "${TIMEOUT}" -gt 0 ]]; then
        echoerr "${cmdname}: waiting ${TIMEOUT} seconds for test command"
    else
        echoerr "${cmdname}: waiting for test command without a timeout"
    fi
    start_ts="$(date +%s)"
    while :
    do
        "${CMD[@]}"
        result="${?}"
        if [[ "${result}" -eq 0 ]]; then
            end_ts="$(date +%s)"
            echoerr "${cmdname}: Test command succeeded after $((end_ts - start_ts)) seconds"
            break
        fi
        sleep 1
    done
    return "${result}"
}

wait_for_wrapper()
{
    # In order to support SIGINT during timeout: http://unix.stackexchange.com/a/57692
    if [[ "${QUIET}" -eq 1 ]]; then
        timeout ${BUSYTIMEFLAG} "${TIMEOUT}" "${0}" --quiet --child --timeout="${TIMEOUT}" "${CMD[@]}" 2>&1 >/dev/null &
    else
        timeout ${BUSYTIMEFLAG} "${TIMEOUT}" "${0}" --child --timeout="${TIMEOUT}" "${CMD[@]}" 2>&1 >/dev/null &
    fi
    PID="${!}"
    trap "kill -INT -${PID}" INT
    wait "${PID}"
    RESULT="${?}"
    if [[ "${RESULT}" -ne 0 ]]; then
        echoerr "${cmdname}: timeout occurred after waiting ${TIMEOUT} seconds for test command"
    fi
    return "${RESULT}"
}

# process arguments
while [[ "${#}" -gt 0 ]]
do
    case "${1}" in
        --child)
            CHILD=1
            shift 1
        ;;
        -q | --quiet)
            QUIET=1
            shift 1
        ;;
        -s | --strict)
            STRICT=1
            shift 1
        ;;
        -t)
            TIMEOUT="${2}"
            if [[ "${TIMEOUT}" == "" ]]; then break; fi
            shift 2
        ;;
        --timeout=*)
            TIMEOUT="${1#*=}"
            shift 1
        ;;
        --help)
            usage
        ;;
        *)
            CMD=()
            while [[ "${#}" -gt 0 ]]
            do
                case "${1}" in
                    --)
                        shift 1
                        CLI=("${@}")
                        break
                    ;;
                    *)
                        CMD+=("${1}")
                        shift 1
                    ;;
                esac
            done
            break
        ;;
    esac
done

if [[ "${CMD[@]}" == "" ]]; then
    echoerr "Error: you need to provide a test command."
    usage
fi

TIMEOUT="${TIMEOUT:-15}"
STRICT="${STRICT:-0}"
CHILD="${CHILD:-0}"
QUIET="${QUIET:-0}"

# check to see if timeout is from busybox?
TIMEOUT_PATH="$(realpath "$(which timeout)")"
if [[ "${TIMEOUT_PATH}" =~ "busybox" ]]; then
        BUSYTIMEFLAG="-t"
else
        BUSYTIMEFLAG=""
fi

if [[ "${CHILD}" -gt 0 ]]; then
    wait_for
    RESULT="${?}"
    exit "${RESULT}"
else
    if [[ "${TIMEOUT}" -gt 0 ]]; then
        wait_for_wrapper
        RESULT="${?}"
    else
        wait_for
        RESULT="${?}"
    fi
fi

if [[ "${CLI}" != "" ]]; then
    if [[ "${RESULT}" -ne 0 && "${STRICT}" -eq 1 ]]; then
        echoerr "${cmdname}: strict mode, refusing to execute subprocess"
        exit "${RESULT}"
    fi
    exec "${CLI[@]}"
else
    exit "${RESULT}"
fi
